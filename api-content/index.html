{"posts":[{"title":"Ant Design Pro 脚手架使用","content":"在Ant design pro中umi@4是不支持umi ui可视化辅助编程工具（右下角的小球球），umi@3才支持umi ui可视化辅助编程工具。(Nodejs 16) 在Ant design pro官网默认使用的是umi@4，想要使用umi@3需要先卸载当前安装的pro-cli，卸载命令如下： npm uninstall -g @ant-design/pro-cli 然后指定版本安装，经过我的测试 3.1.0 这个版本就可以选择 umi 版本，重新使用 npm install -g @ant-design/pro-cli@3.1.0 安装 pro-cli 即可 npm install -g @ant-design/pro-cli@3.1.0 然后再去初始化脚手架，就可以选择umi@3了。命令： npx pro create myapp 再去安装依赖，使用yarn 或者npm install 都可以。之后再去添加umi ui，命令 yarn add @umijs/preset-ui -D 最后 npm run start 脚手架启动成功 ","link":"https://hdward.github.io/post/ant-design-pro-jiao-shou-jia-shi-yong/"},{"title":"User角色管理","content":"package com.hdward.controller; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.hdward.domain.ResponseResult; import com.hdward.domain.dto.UserQueryDTO; import com.hdward.domain.vo.UserVo; import com.hdward.emums.AppHttpCodeEnum; import com.hdward.entity.User; import com.hdward.mapper.UserMapper; import com.hdward.service.UserService; import com.hdward.utils.BeanCopyUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/user&quot;) public class UserController { @Autowired private UserService userService; //添加角色 @PostMapping(&quot;/addUser&quot;) public ResponseResult addUser(@RequestBody User user) { if (userService.addUser(user)) { return ResponseResult.okResult(); } else { return ResponseResult.errorResult(AppHttpCodeEnum.USERNAME_EXIST); } } //删除角色：批量删除 @PostMapping(&quot;/deleteUser&quot;) public ResponseResult deleteUser(@RequestBody List&lt;Long&gt; ids) { if (userService.deleteUser(ids)){ return ResponseResult.okResult(); }else { return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR); } } //编辑角色 @PostMapping(&quot;/updateUser&quot;) public ResponseResult updateUser(@RequestBody User user) { if (userService.updateUser(user)) { return ResponseResult.okResult(); } else { return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR); } } //分页查询:根据用户名查询角色如果不输入用户名则查询所有角色 @GetMapping(&quot;/getUserList&quot;) public Page&lt;User&gt; getUserList(@RequestBody UserQueryDTO queryDTO){ return userService.getUserList(queryDTO); } } package com.hdward.service; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.extension.service.IService; import com.hdward.domain.dto.UserQueryDTO; import com.hdward.entity.User; import java.util.List; public interface UserService extends IService&lt;User&gt; { boolean addUser(User user); boolean deleteUser(List&lt;Long&gt; ids); boolean updateUser(User user); Page&lt;User&gt; getUserList(UserQueryDTO queryDTO); } package com.hdward.service.impl; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.toolkit.CollectionUtils; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.hdward.domain.dto.UserQueryDTO; import com.hdward.entity.User; import com.hdward.mapper.UserMapper; import com.hdward.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.Collections; import java.util.Date; import java.util.List; @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService { @Autowired private UserMapper userMapper; @Override public boolean addUser(User user) { // 校验用户姓名是否为空 if (user.getUserName() == null || user.getUserName().trim().isEmpty()) { return false; // 用户名不能为空 } // 校验角色(admin)是否为空 if (user.getAdmin() == null) { return false; // 角色不能为空 } // 校验角色值是否有效（True 表示管理员，False 表示普通成员） if (!user.getAdmin().equals(Boolean.TRUE) &amp;&amp; !user.getAdmin().equals(Boolean.FALSE)) { return false; // 角色无效 } // 检查用户名是否已存在 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;user_name&quot;, user.getUserName()); User existingUser = userMapper.selectOne(queryWrapper); // 如果用户名已存在，返回false if (existingUser != null) { return false; // 用户已存在 } // 设置创建时间和修改时间 //user.setCreateAt(new Date()); //user.setModifiedAt(new Date()); // 执行插入操作 int rowsAffected = userMapper.insert(user); // 返回插入结果 return rowsAffected &gt; 0; } @Override public boolean deleteUser(List&lt;Long&gt; ids) { // 使用CollectionUtils.isEmpty()判断ids是否为空 if (CollectionUtils.isEmpty(ids)) { return false; // 如果ids为空或空列表，直接返回false } // 使用MyBatis-Plus提供的removeByIds方法批量删除 int rowsAffected = userMapper.deleteBatchIds(ids); // 返回操作结果，判断受影响的行数是否大于0 return rowsAffected &gt; 0; } @Override public boolean updateUser(User user) { // 校验用户ID是否存在 if (user.getId() == null) { return false; // 用户ID不能为空 } // 校验角色(admin)是否为空 if (user.getAdmin() == null) { return false; // 角色不能为空 } // 校验角色值是否有效（True 表示管理员，False 表示普通成员） if (!user.getAdmin().equals(Boolean.TRUE) &amp;&amp; !user.getAdmin().equals(Boolean.FALSE)) { return false; // 角色无效 } // 校验用户是否存在 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(&quot;id&quot;, user.getId()); User existingUser = userMapper.selectOne(queryWrapper); // 如果用户不存在，返回false if (existingUser == null) { return false; // 用户不存在 } // 设置修改时间 //user.setModifiedAt(new Date()); // 执行更新操作 int rowsAffected = userMapper.updateById(user); // 返回操作结果 return rowsAffected &gt; 0; } @Override public Page&lt;User&gt; getUserList(UserQueryDTO queryDTO) { // 创建分页对象 Page&lt;User&gt; page = new Page&lt;&gt;(queryDTO.getPageNum(), queryDTO.getPageSize()); // 创建查询条件 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); // 根据userName查询 if (queryDTO.getUserName() != null &amp;&amp; !queryDTO.getUserName().trim().isEmpty()) { queryWrapper.like(&quot;user_name&quot;, queryDTO.getUserName()); } // 根据admin查询（0: 普通成员, 1: 管理员） if (queryDTO.getAdmin() != null) { queryWrapper.eq(&quot;admin&quot;, queryDTO.getAdmin()); } // 根据department查询 if (queryDTO.getDepartment() != null &amp;&amp; !queryDTO.getDepartment().trim().isEmpty()) { queryWrapper.like(&quot;department&quot;, queryDTO.getDepartment()); } // 执行分页查询 return userMapper.selectPage(page, queryWrapper); } } package com.hdward.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.hdward.entity.User; import org.apache.ibatis.annotations.Mapper; @Mapper public interface UserMapper extends BaseMapper&lt;User&gt; { } dto package com.hdward.domain.dto; import lombok.Data; @Data public class UserQueryDTO { private String userName; // 用户名查询条件 private Integer admin; // 角色类型查询条件，0代表普通成员，1代表管理员 private String department; // 部门查询条件 private Integer pageNum = 1; // 当前页，默认第一页 private Integer pageSize = 10; // 每页显示条数，默认10条 // 其他需要的查询条件可以继续扩展 } user package com.hdward.entity; import com.baomidou.mybatisplus.annotation.*; import lombok.Data; import java.util.Date; @Data @TableName(&quot;users&quot;) public class User { @TableId(value = &quot;id&quot;, type = IdType.AUTO)// 主键 private Long id; @TableField(&quot;user_name&quot;) private String userName; @TableField(&quot;admin&quot;) private Boolean admin; @TableField(&quot;name&quot;) private String name; @TableField(value = &quot;create_at&quot;, fill = FieldFill.INSERT) private Date createAt; @TableField(value = &quot;modified_at&quot;, fill = FieldFill.INSERT_UPDATE) private Date modifiedAt; @TableField(&quot;uuid&quot;) private String uuid; @TableField(&quot;mobile&quot;) private String mobile; @TableField(&quot;email&quot;) private String email; @TableField(&quot;department&quot;) private String department; @TableField(&quot;name_zh&quot;) private String nameZh; @TableField(&quot;name_en&quot;) private String nameEn; } ","link":"https://hdward.github.io/post/user-jiao-se-guan-li/"},{"title":"Java热门面试题200","content":"Java面试题 1.说说Java中的HashMap原理？ HashMap 是一个基于哈希表的数据结构，通过键的哈希值快速定位存储位置。 底层由数组+链表（红黑树JDK1.8）实现，通过键的hashCode()方法计算出哈希值，然后由哈希值和数组长度得出一个索引（公式：index = (数组长度 - 1) &amp; hash(key)），发送哈希冲突时会使用链表或者红黑树来存储这些冲突的键值对。当数组长度不够时，会进行扩容至原来的2倍。 特点： 无序 允许空键和空值 非线程安全 需要线程安全，可以用 ConcurrentHashMap 2.Java中'ConcurrentHashMap' 1.7和1.8之间有哪些区别？ ​ Java 1.7 的 ConcurrentHashMap 像是一个大仓库，分成多个小房间（Segment），每个房间有自己的锁。 Java 1.8 的 ConcurrentHashMap 更像是一个大仓库，每个货架（桶）有自己的锁，锁的粒度更小，效率更高。 Java 1.8 还引入了红黑树，解决了链表过长时查找效率低的问题。 3.为什么JDK1.8对HashMap 进行了红黑树的改动？ JDK 1.7 的 HashMap 在链表过长时，性能会变差。 JDK 1.8 引入了红黑树，当链表太长时，把它变成一棵树，查找速度更快。 红黑树的引入是为了解决极端情况下的性能问题，同时平衡了时间和空间的开销。 注： 链表转红黑树：当链表长度超过 8 时，链表会转换为红黑树。 红黑树转链表：当红黑树的节点数减少到 6 时，红黑树会转换回链表。 4.JDK1.8 对 HashMap 除了红黑树还进行了哪些改动? JDK 1.8 对 HashMap 的改进主要集中在以下几个方面： 性能优化：引入红黑树、优化哈希算法、改进扩容机制。 安全性提升：链表插入方式改为尾插法，避免死循环。 功能增强：支持函数式编程，提供更丰富的 API。 代码优化：重构代码，提高可读性和可维护性。 这些改动使得 HashMap 在 JDK 1.8 中性能更高、更安全、更易用。 5.Java 中有哪些集合类?请简单介绍 ​ Java中集合主要分为两大类：Collection接口和Map接口，前者存储对象的集合类，后者存储的是键值对。 ​ Collection接口下又分为List Set Queue . ​ List接口（有序可重复）： ​ 常用实现类:ArrayList：基于动态数组实现，查询快，增删慢。 ​ LinkedList：基于双向链表实现，增删快，查询慢。 Vector：线程安全的动态数组，性能较差（已被 ArrayList 取代）。 ​ Set:无序不可重复。 ​ HashSet：基于哈希表实现，查询速度快，元素无序。 LinkedHashSet：基于哈希表和链表实现，元素按插入顺序排列。 TreeSet：基于红黑树实现，元素按自然顺序或自定义顺序排序。 （1）Map（键不可重复） 特点：键值对存储，键不允许重复，值可以重复。 常用实现类： HashMap：基于哈希表实现，键值对无序，查询速度快。 LinkedHashMap：基于哈希表和链表实现，键值对按插入顺序排列。 TreeMap：基于红黑树实现，键值对按自然顺序或自定义顺序排序。 Hashtable：线程安全的哈希表，性能较差（已被 HashMap 取代）。 ConcurrentHashMap：线程安全的哈希表，性能优于 Hashtable。 5.MySQL索引的最左前缀匹配原则是什么? 1. 什么是复合索引？ 复合索引是指对表中多个列组合起来创建的索引。比如： CREATE INDEX idx_name_age ON users(name, age); 这里创建了一个复合索引，包含 name 和 age 两个列。 2. 最左前缀匹配原则是什么？ 最左前缀匹配原则是指：在使用复合索引时，MySQL 会从索引的最左边开始匹配查询条件。也就是说，查询条件必须包含复合索引的最左边的列，才能利用索引。 3. 举个例子 假设有一个复合索引 idx_name_age，包含两列：name 和 age。 （1）能使用索引的情况 查询条件包含最左列 name： SELECT * FROM users WHERE name = 'Alice'; 这里使用了 name 列，符合最左前缀匹配原则，索引生效。 查询条件包含最左列 name 和第二列 age： SELECT * FROM users WHERE name = 'Alice' AND age = 25; 这里同时使用了 name 和 age 列，符合最左前缀匹配原则，索引生效。 （2）不能使用索引的情况 查询条件不包含最左列 name： SELECT * FROM users WHERE age = 25; 这里只使用了 age 列，没有使用最左列 name，不符合最左前缀匹配原则，索引失效。 查询条件跳过了最左列 name： SELECT * FROM users WHERE age = 25 AND name = 'Alice'; 虽然查询条件中包含了 name 和 age，但 name 不是最左列的条件，索引仍然可能失效（取决于 MySQL 的优化器）。 4. 特殊情况：部分匹配 如果查询条件只包含复合索引的一部分列，但仍然从最左列开始匹配，索引仍然可以部分生效。 例如： SELECT * FROM users WHERE name = 'Alice'; 这里只使用了 name 列，索引仍然生效。 5. 总结 最左前缀匹配原则：使用复合索引时，查询条件必须从索引的最左列开始匹配。 能使用索引的情况： 查询条件包含最左列。 查询条件包含最左列及其后的列。 不能使用索引的情况： 查询条件不包含最左列。 查询条件跳过了最左列。 6. 通俗理解 可以把复合索引想象成一本字典： 字典的目录是按照字母顺序排列的（比如 A-Z）。 如果你只知道第二个字母（比如 B），而没有第一个字母（比如 A），你是无法快速查找的。 只有从第一个字母开始查找，才能快速定位到目标。 6.数据库的脏读、不可重复读和幻读分别是什么? 脏读：读到别人没写完的草稿。 不可重复读：同一件事，两次看到的结果不一样。就像你第一次看一本书的某一页，内容是 A；第二次再看时，内容被改成了 B。 幻读：同一范围的数据，两次查询的结果集不一样。就像你第一次数教室里有 10 个人，第二次数时突然多了一个人。 7.MySQL的存储引擎有哪些?它们之间有什么区别? 需要事务支持：选择 InnoDB。 读多写少，不需要事务：选择 MyISAM。 临时数据或缓存：选择 MEMORY。 日志或归档数据：选择 ARCHIVE。 数据导入导出：选择 CSV。 以下是这些存储引擎的主要特点和区别： 特性 InnoDB MyISAM MEMORY ARCHIVE CSV 事务支持 支持（ACID 事务） 不支持 不支持 不支持 不支持 外键支持 支持 不支持 不支持 不支持 不支持 锁粒度 行级锁 表级锁 表级锁 行级锁 表级锁 崩溃恢复 支持（通过日志恢复） 不支持 数据丢失 不支持 不支持 存储限制 64TB 256TB 内存限制 无明确限制 文件大小限制 索引类型 聚簇索引 非聚簇索引 哈希索引 不支持索引 不支持索引 适用场景 高并发、事务性操作 读多写少、非事务性操作 临时数据、缓存 日志存储、归档数据 数据导入导出 8.MySQL 的覆盖索引是什么? 1. 什么是覆盖索引？ 覆盖索引是指：一个索引包含了查询所需的所有字段，因此查询可以直接通过索引获取数据，而无需回表（即无需再去读取数据行）。 2. 覆盖索引的原理 通常情况下，MySQL 的查询需要两步： 通过索引查找数据的位置（索引扫描）。 根据位置去数据表中读取具体的行（回表操作）。 如果使用覆盖索引，查询所需的所有字段都包含在索引中，因此 MySQL 可以直接从索引中获取数据，跳过回表操作。 3. 举个例子 假设有一张表 users，结构如下： CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50), age INT, city VARCHAR(50) ); （1）普通索引查询 创建一个普通索引： CREATE INDEX idx_name ON users(name); 执行查询： SELECT name, age FROM users WHERE name = 'Alice'; 这个查询需要两步： 通过索引 idx_name 找到 name = 'Alice' 的行。 根据索引中的位置，回表读取 age 字段。 （2）覆盖索引查询 创建一个覆盖索引： CREATE INDEX idx_name_age ON users(name, age); 执行查询： SELECT name, age FROM users WHERE name = 'Alice'; 这个查询只需要一步： 通过索引 idx_name_age 直接获取 name 和 age 字段，无需回表。 4. 覆盖索引的好处 减少 I/O 操作：无需回表，减少了磁盘 I/O 操作，提高了查询性能。 减少 CPU 开销：索引通常比数据行小，扫描索引比扫描数据行更快。 适合查询优化：对于只查询少量字段的场景，覆盖索引可以显著提升性能。 5. 如何判断是否使用了覆盖索引？ 在 MySQL 中，可以通过 EXPLAIN 命令查看查询的执行计划。如果 Extra 列显示 Using index，说明使用了覆盖索引。 例如： EXPLAIN SELECT name, age FROM users WHERE name = 'Alice'; 如果输出中 Extra 列显示 Using index，则表示使用了覆盖索引。 6. 覆盖索引的限制 索引大小：覆盖索引需要包含查询的所有字段，如果字段较多或字段较大，索引会占用更多存储空间。 写操作开销：覆盖索引会增加写操作（如 INSERT、UPDATE、DELETE）的开销，因为需要维护更多的索引。 7. 通俗总结 覆盖索引就像一本书的目录，如果目录中已经包含了你想查找的内容，你就不需要翻到具体的页面了。 使用覆盖索引可以避免回表操作，提高查询性能。 9.MySQL 的索引类型有哪些? B-Tree 索引：万能索引，适合大多数场景。 哈希索引：适合快速查找，但不支持范围查询。 全文索引：适合搜索文本内容。 空间索引：适合地理数据。 前缀索引：适合长字段。 复合索引：适合多条件查询。 唯一索引：适合需要唯一性的字段。 ​ ","link":"https://hdward.github.io/post/java-re-men-mian-shi-ti-200/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hdward.github.io/post/hello-gridea/"}]}